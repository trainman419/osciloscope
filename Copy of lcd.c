
#include "lcd.h"
#include "m_map.h"
#include "fsl.h"

const unsigned char FONT6x8[97][8];
void InitLcd(void);

#define WriteSpiCommand(c) putfsl(c, 0)
#define WriteSpiData(d) cputfsl(d, 0)

void lcd_tx(unsigned char x) {
	while(LCD_SR & 0x8);
	LCD_TX = x;
}

signed short lcd_rx() {
	return lcd_rx_timeout(1000000); // hopefully about 1s
}

signed short lcd_rx_timeout(int timeout) {
	int i=0;
	for( i=0; (i<timeout) && !(LCD_SR & 0x1); i++);
	if( LCD_SR & 0x1 ) return LCD_RX;
	else return -1;
}

void lcd_command(unsigned char * cmd, unsigned short len) {
	int i, done, j;
	signed short rx;
	done = 0;
	j=0;
	SSEG = (cmd[0]<<8);

	while(lcd_rx_timeout(1) != -1);
	
	while(!done && j < 10) {
		for( i=0; i<len; i++) {
			lcd_tx(cmd[i]);
			SSEG = (j*len + i) | (cmd[0]<<8);
		}
		rx = lcd_rx();
		if( rx == 0x06 ) done = 1; // if we got an ack
		while(rx == -1) {
			lcd_tx('P');
			rx = lcd_rx();
		}
		j++;
		while(lcd_rx_timeout(1) != -1);
	}
	SSEG = cmd[0]<<8;
}

void InitLcd(void) {
	unsigned char cmd[3];
	SSEG = 1;
	// display reset
	GPIO = 0; // reset low
	delay_ms(1);
	GPIO = 1; // reset high
	delay_ms(1000); // wait for display init
	LCD_CR = 0x3; // reset fifos
	LCD_CR = 0x0;
	lcd_tx('U'); // auto-baud init
	delay_ms(1);
	// wait for ACK here
	
	SSEG = 2;
	cmd[0] = 'Y';
	cmd[1] = 1; // mode on/off
	cmd[2] = 1; // on
	lcd_command(cmd, 3);
	
	SSEG = 3;
	cmd[1] = 2; // mode contrast
	cmd[2] = 8; // contrast 8 of 15
	lcd_command(cmd, 3);

	SSEG = 4;
	cmd[1] = 3; // mode OLED on/off
	cmd[2] = 1; // on
	lcd_command(cmd, 3);
	
	SSEG = 5;
}

void LCD_off() {
	unsigned char cmd[] = {'Y', 3, 0}; // mode OLED on/off; off
	lcd_command(cmd, 3);
}

void LCD_put_pixel(unsigned char x, unsigned char y, unsigned short color) {
	unsigned char cmd[5];
	int i;
	cmd[0] = 'P';
	cmd[1] = x;
	cmd[2] = y;
	cmd[3] = (color >> 8) & 0xFF;
	cmd[4] = color & 0xFF;
	lcd_command(cmd, 5);
	/*for(i=0; i<5; i++) {
		lcd_tx(cmd[i]);
	}
	lcd_rx();*/
}

void LCD_draw_rect(unsigned char x1, unsigned char y1,
						 unsigned char x2, unsigned char y2,
						 unsigned short color) {
	unsigned char cmd[7];
	cmd[0] = 'r';
	cmd[1] = x1;
	cmd[2] = y1;
	cmd[3] = x2;
	cmd[4] = y2;
	cmd[5] = (color >> 8) & 0xFF;
	cmd[6] = color & 0xFF;
	lcd_command(cmd, 7);
}

void LCD_draw_line(unsigned char x1, unsigned char y1,
						 unsigned char x2, unsigned char y2,
						 unsigned short color) {
	unsigned char cmd[7];
	cmd[0] = 'L';
	cmd[1] = x1;
	cmd[2] = y1;
	cmd[3] = x2;
	cmd[4] = y2;
	cmd[5] = (color >> 8) & 0xFF;
	cmd[6] = color & 0xFF;
	lcd_command(cmd, 7);
}

void LCD_pen_size(unsigned char s) {
	unsigned char cmd[2];
	cmd[0] = 'p';
	cmd[1] = s;
	lcd_command(cmd, 2);
}

void LCDContrast(unsigned char c) {
}

void LCDClearScreen(unsigned short int color) {
}

void LCDb_clear(unsigned short int color, unsigned short * b) {
	int i=0;
	for(i=0; i<(LCD_ROWS * LCD_COLS); i++) b[i] = color;
}

// color format: RRRRRGGG GGGBBBBB
void LCD_blit(unsigned short int * buffer) {
	int done, i;
	done = 0;
	signed short rx;
	while(!done) {
		// dispaly image command
		lcd_tx('I');
		lcd_tx(0); // top left, x = 0
		lcd_tx(0); // top left, y = 0
		lcd_tx(160); // width = 160
		lcd_tx(128); // height = 128
		lcd_tx(16); // 16 bits/pixel
		for(i = 0; i < (LCD_ROWS * LCD_COLS); i++) {
			lcd_tx( ((buffer[i] & 0xFF00) >> 8) & 0xFF);
			lcd_tx(buffer[i] & 0xFF);
		}
		rx = lcd_rx();
		if( rx == 0x06 ) done = 1;
		while( rx == -1 ) {
			lcd_tx(0);
			rx= lcd_rx();
		}
	}
}

void LCDb_set_line(int x0, int y0, int x1, int y1, int color, 
	unsigned short * b) {
	int dy = y1 - y0;
	int dx = x1 - x0;
	int stepx, stepy;
	
	if (dy < 0) { dy = -dy; stepy = -1; } else { stepy = 1; }
	if (dx < 0) { dx = -dx; stepx = -1; } else { stepx = 1; }
	
	dy <<= 1; // dy is now 2*dy
	dx <<= 1; // dx is now 2*dx
	
	LCDb_set_pixel(x0, y0, color, b);
	
	if (dx > dy) {
		int fraction = dy - (dx >> 1); // same as 2*dy - dx

		while (x0 != x1) {
			if (fraction >= 0) {
				y0 += stepy;
				fraction -= dx; // same as fraction -= 2*dx
			}
			x0 += stepx;
			fraction += dy; // same as fraction -= 2*dy
			LCDb_set_pixel(x0, y0, color, b);
		}
	} else {
		int fraction = dx - (dy >> 1);

		while (y0 != y1) {
			if (fraction >= 0) {
				x0 += stepx;
				fraction -= dy;
			}
			y0 += stepy;
			fraction += dx;
			LCDb_set_pixel(x0, y0, color, b);
		}
	}
}

void LCDb_set_rect(int x0, int y0, int x1, int y1, unsigned char fill, int color,
	unsigned short * b) {
	int xmin, xmax, ymin, ymax;
	int i, j;

	// check if the rectangle is to be filled
	if (fill == FILL) {
		// doing drawing manually; offset to compensate for display
		/*x0 += 2;
		x1 += 2;*/
		
		// best way to create a filled rectangle is to define a drawing box
		// and loop two pixels at a time
		// calculate the min and max for x and y directions
		xmin = (x0 <= x1) ? x0 : x1;
		xmax = (x0 > x1) ? x0 : x1;
		ymin = (y0 <= y1) ? y0 : y1;
		ymax = (y0 > y1) ? y0 : y1;
		
		for( i=xmin; i<=xmax; i++ ) {
			for( j=ymin; j<=ymax; j++ ) {
				LCDb_set_pixel(i, j, color, b);
			}
		}
	} else {
		// best way to draw un unfilled rectangle is to draw four lines
		LCDb_set_line(x0, y0, x1, y0, color, b);
		LCDb_set_line(x0, y1, x1, y1, color, b);
		LCDb_set_line(x0, y0, x0, y1, color, b);
		LCDb_set_line(x1, y0, x1, y1, color, b);
	}
}

void LCDb_set_circle(int x0, int y0, int radius, int color,
	unsigned short * b) {
	int f = 1 - radius;
	int ddF_x = 0;
	int ddF_y = -2 * radius;
	int x = 0;
	int y = radius;

	LCDb_set_pixel(x0, y0 + radius, color, b);
	LCDb_set_pixel(x0, y0 - radius, color, b);
	LCDb_set_pixel(x0 + radius, y0, color, b);
	LCDb_set_pixel(x0 - radius, y0, color, b);

	while(x < y) {
		if(f >= 0) {
			y--;
			ddF_y += 2;
			f += ddF_y;
		}

		x++;
		ddF_x += 2;
		f += ddF_x + 1;

		LCDb_set_pixel(x0 + x, y0 + y, color, b);
		LCDb_set_pixel(x0 - x, y0 + y, color, b);
		LCDb_set_pixel(x0 + x, y0 - y, color, b);
		LCDb_set_pixel(x0 - x, y0 - y, color, b);
		LCDb_set_pixel(x0 + y, y0 + x, color, b);
		LCDb_set_pixel(x0 - y, y0 + x, color, b);
		LCDb_set_pixel(x0 + y, y0 - x, color, b);
		LCDb_set_pixel(x0 - y, y0 - x, color, b);
	}
}

void LCDb_put_char(char c, int x, int y, int size, int fColor, int bColor,
	unsigned short * b) {
	extern const unsigned char FONT6x8[97][8];
	int i,j;
	unsigned int nCols;
	unsigned int nRows;
	unsigned int nBytes;
	unsigned char PixelRow;
	unsigned char Mask;
	unsigned int Word0;
	unsigned int Word1;
	unsigned char *pFont;
	unsigned char *pChar;
	// get pointer to the beginning of the selected font table
	pFont = (unsigned char *)FONT6x8;
	// get the nColumns, nRows and nBytes
	nCols = pFont[0];
	nRows = pFont[1];
	nBytes = pFont[2];
	// get pointer to the last byte of the desired character
	// this is right
	pChar = pFont + (nBytes * (c - 0x1F));
		
	// loop on each row, working top to bottom
	for (i = 0; i < nRows; i++) {
		// copy pixel row from font table and then decrement row
		PixelRow = pChar[i];
		// loop on each pixel in the row (left to right)
		// Note: we do two pixels each loop
		Mask = 0x80;
		for (j = 0; j < nCols; j++) {
			// if pixel bit set, use foreground color; else use the background color
			// now get the pixel color for two successive pixels
			if ( PixelRow & Mask )
				LCDb_set_pixel(x+j, y+i, fColor, b);
			else
				LCDb_set_pixel(x+j, y+i, bColor, b);
			
			Mask = Mask >> 1;
		}
	}
}

void LCDb_put_str(char *pString, int x, int y, int Size, int fColor, int bColor,
	unsigned short * b) {
	// loop until null-terminator is seen
	while (*pString != 0x00) {
		// draw the character
		LCDb_put_char(*pString++, x, y, Size, fColor, bColor, b);

		// advance the y position
		if (Size == SMALL)
			x = x + 6;
		else if (Size == MEDIUM)
			x = x + 8;
		else
			x = x + 8;

		// bail out if y exceeds columns
		if (x > (LCD_COLS-8) ) break;
	}
}

void Delay (unsigned long a) {
	while (--a!=0);
}

// *********************************************************************************
//
// Font tables for Nokia 6610 LCD Display Driver (S1D15G00 Controller)
//
// FONT6x8 - SMALL font (mostly 5x7)
//
// Note: ASCII characters 0x00 through 0x1F are not included in these fonts.
//
// Author: Jim Parise, James P Lynch August 30, 2007
// *********************************************************************************
const unsigned char FONT6x8[97][8] = {
0x06,0x08,0x08,0x00,0x00,0x00,0x00,0x00, // columns, rows, num_bytes_per_char
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // space 0x20
0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00, // !
0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00, // "
0x50,0x50,0xF8,0x50,0xF8,0x50,0x50,0x00, // #
0x20,0x78,0xA0,0x70,0x28,0xF0,0x20,0x00, // $
0xC0,0xC8,0x10,0x20,0x40,0x98,0x18,0x00, // %
0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,0x00, // &
0x30,0x30,0x20,0x40,0x00,0x00,0x00,0x00, // '
0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00, // (
0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00, // )
0x00,0x20,0xA8,0x70,0x70,0xA8,0x20,0x00, // *
0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00, // +
0x00,0x00,0x00,0x00,0x30,0x30,0x20,0x40, // ,
0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00, // -
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00, // .
0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00, // / (forward slash)
0x70,0x88,0x88,0xA8,0x88,0x88,0x70,0x00, // 0 0x30
0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00, // 1
0x70,0x88,0x08,0x70,0x80,0x80,0xF8,0x00, // 2
0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x00, // 3
0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00, // 4
0xF8,0x80,0xF0,0x08,0x08,0x88,0x70,0x00, // 5
0x38,0x40,0x80,0xF0,0x88,0x88,0x70,0x00, // 6
0xF8,0x08,0x08,0x10,0x20,0x40,0x80,0x00, // 7
0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00, // 8
0x70,0x88,0x88,0x78,0x08,0x10,0xE0,0x00, // 9
0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x00, // :
0x00,0x00,0x20,0x00,0x20,0x20,0x40,0x00, // ;
0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00, // <
0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00, // =
0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00, // >
0x70,0x88,0x08,0x30,0x20,0x00,0x20,0x00, // ?
0x70,0x88,0xA8,0xB8,0xB0,0x80,0x78,0x00, // @ 0x40
0x20,0x50,0x88,0x88,0xF8,0x88,0x88,0x00, // A
0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00, // B
0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00, // C
0xF0,0x88,0x88,0x88,0x88,0x88,0xF0,0x00, // D
0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x00, // E
0xF8,0x80,0x80,0xF0,0x80,0x80,0x80,0x00, // F
0x78,0x88,0x80,0x80,0x98,0x88,0x78,0x00, // G
0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00, // H
0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // I
0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x00, // J
0x88,0x90,0xA0,0xC0,0xA0,0x90,0x88,0x00, // K
0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00, // L
0x88,0xD8,0xA8,0xA8,0xA8,0x88,0x88,0x00, // M
0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00, // N
0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // O
0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00, // P 0x50
0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00, // Q
0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00, // R
0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00, // S
0xF8,0xA8,0x20,0x20,0x20,0x20,0x20,0x00, // T
0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // U
0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00, // V
0x88,0x88,0x88,0xA8,0xA8,0xA8,0x50,0x00, // W
0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00, // X
0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00, // Y
0xF8,0x08,0x10,0x70,0x40,0x80,0xF8,0x00, // Z
0x78,0x40,0x40,0x40,0x40,0x40,0x78,0x00, // [
0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00, // \ (back slash)
0x78,0x08,0x08,0x08,0x08,0x08,0x78,0x00, // ]
0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00, // ^
0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00, // _
0x60,0x60,0x20,0x10,0x00,0x00,0x00,0x00, // ` 0x60
0x00,0x00,0x60,0x10,0x70,0x90,0x78,0x00, // a
0x80,0x80,0xB0,0xC8,0x88,0xC8,0xB0,0x00, // b
0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x00, // c
0x08,0x08,0x68,0x98,0x88,0x98,0x68,0x00, // d
0x00,0x00,0x70,0x88,0xF8,0x80,0x70,0x00, // e
0x10,0x28,0x20,0x70,0x20,0x20,0x20,0x00, // f
0x00,0x00,0x70,0x98,0x98,0x68,0x08,0x70, // g
0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x00, // h
0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00, // i
0x10,0x00,0x10,0x10,0x10,0x90,0x60,0x00, // j
0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00, // k
0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // l
0x00,0x00,0xD0,0xA8,0xA8,0xA8,0xA8,0x00, // m
0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00, // n
0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00, // o
0x00,0x00,0xB0,0xC8,0xC8,0xB0,0x80,0x80, // p 0x70
0x00,0x00,0x68,0x98,0x98,0x68,0x08,0x08, // q
0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00, // r
0x00,0x00,0x78,0x80,0x70,0x08,0xF0,0x00, // s
0x20,0x20,0xF8,0x20,0x20,0x28,0x10,0x00, // t
0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00, // u
0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00, // v
0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00, // w
0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00, // x
0x00,0x00,0x88,0x88,0x78,0x08,0x88,0x70, // y
0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00, // z
0x10,0x20,0x20,0x40,0x20,0x20,0x10,0x00, // {
0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00, // |
0x40,0x20,0x20,0x10,0x20,0x20,0x40,0x00, // }
0x40,0xA8,0x10,0x00,0x00,0x00,0x00,0x00, // ~
0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00}; // DEL
